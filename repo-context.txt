# Repository Context

Generated on: 2025-01-17

## Directory Tree with Exclusions

```
.
    ├── .gitattributes
    ├── .gitignore
    ├── README.md
    ├── XML-Prompt.md
    ├── repo-context.txt
    ├── saved_config.yaml
    ├── test1/
        ├── src/
            ├── index.js
            ├── package-lock.json
            ├── package.json
            ├── scripts/
                ├── webpack.config.js
            ├── js/
                ├── webtorrent.min.js
            ├── dist/
                ├── bundle.js
                ├── bundle.js.map
                ├── index.html
                ├── magnet-link.txt
                ├── sw.min.js
```

## Important Files

## webtorrent-stream-example/XML-Prompt.md
```markdown
Present a complete plan to solve the problem and implement it in the codebase.

At the end of your response, respond with the following XML section (if applicable).

XML Section:

Do not get lazy. Always output the full code in the XML section.
Enclose this entire section in a markdown codeblock
Include all of the changed files
Specify each file operation with CREATE, UPDATE, or DELETE
For CREATE or UPDATE operations, include the full file code
Include the full file path (relative to the project directory, good: app/page.tsx, bad: /Users/mckaywrigley/Desktop/projects/new-chat-template/app/page.tsx)
Enclose the code with ![CDATA[CODE HERE]]
Use the following XML structure:
<code_changes>
  <changed_files>
    <file>
      <file_operation>__FILE OPERATION HERE__</file_operation>
      <file_path>__FILE PATH HERE__</file_path>
      <file_code><![CDATA[
__FULL FILE CODE HERE__
]]></file_code>
    </file>
    __REMAINING FILES HERE__
  </changed_files>
</code_changes>
Other rules:

DO NOT remove <ai_context> sections. These are to provide you additional context about each file.
If you create a file, add an <ai_context> comment section at the top of the file.
If you update a file make sure its <ai_context> stays up-to-date
DO NOT add comments related to your edits
DO NOT remove my existing comments
We may go back and forth a few times. If we do, remember to continue to output the entirety of the code in an XML section (if applicable).

Take all the time you need.
```

## webtorrent-stream-example/saved_config.yaml
```
excluded_files:
- test1/src/dist/bundle.js.map
- test1/src/dist/bundle.js
- test1/src/js/webtorrent.min.js
selected_directories:
- test1/
- test1/src/
- test1/src/scripts/
- test1/src/js/
- test1/src/dist/

```

## webtorrent-stream-example/README.md
```markdown
# How to Install & Build with Webpack

This guide covers installing Node, bundling with Webpack, and running the site on both **Windows** and **Debian** systems.

---

## 1. Install Node.js & npm

### Windows
1. Download the [Node.js installer](https://nodejs.org/en/download/) for Windows.
2. Run the installer and follow the steps.
3. Verify installation in a terminal (e.g. PowerShell or cmd):
   ```bash
   node -v
   npm -v
   ```

### Debian / Ubuntu
1. Update your package index:
   ```bash
   sudo apt-get update
   ```
2. Install Node.js and npm:
   ```bash
   sudo apt-get install -y nodejs npm
   ```
3. Verify installation:
   ```bash
   node -v
   npm -v
   ```

---

## 2. Install Dependencies

Inside your project folder (the one containing `package.json`):

```bash
npm install
```

This installs all required packages (including Webpack and Babel).

---

## 3. Build the Project

Run the build script from `package.json`:

```bash
npm run build
```

Webpack will bundle your code and output files to the `dist/` folder.

---

## 4. Serve the Site

1. **Method 1: Node-based static server**  
   If you have a lightweight HTTP server (like `serve` or `http-server`) installed globally, you can do:
   ```bash
   npx http-server dist
   ```
   or
   ```bash
   npx serve dist
   ```
   This starts a local server hosting files from the `dist/` folder.

2. **Method 2: Built-in `webpack` dev server** (if configured)  
   Some setups have a dev server configured. In that case:
   ```bash
   npm start
   ```
   (Or whatever script your `package.json` uses to launch the dev server.)

---

## 5. Open the App

- Once the server is running, open your browser to:
  ```
  http://127.0.0.1:8080
  ```
  *(Adjust the port if your server logs a different port.)*

You should now see the WebTorrent streaming demo functioning in your browser.
```

## src/index.js
```javascript
/*
<ai_context>
this is a new file that imports the local webtorrent library
</ai_context>
*/

import WebTorrent from "./js/webtorrent.min.js";

(async function main() {
  console.log("[App] Starting application...");

  const statusElement = document.getElementById("status");
  const videoPlayer = document.getElementById("videoPlayer");

  try {
    console.log("[App] Registering service worker...");
    const reg = await navigator.serviceWorker.register("./sw.min.js", { scope: "./" });
    await navigator.serviceWorker.ready;

    if (!navigator.serviceWorker.controller) {
      console.log("[App] SW not controlling this page yet. Reloading...");
      location.reload();
      return;
    }
    console.log("[App] Service worker controlling page:", navigator.serviceWorker.controller.scriptURL);

    statusElement.textContent = "Initializing WebTorrent...";
    const client = new WebTorrent();
    client.createServer({ controller: reg });

    function onSWMessage(evt) {
      const data = evt.data;
      if (!data || data.type !== "webtorrent") return;
      if (typeof client._onServiceWorkerRequest === "function") {
        client._onServiceWorkerRequest(data, evt.ports[0]);
      } else {
        console.warn("[App] No client._onServiceWorkerRequest found - fallback needed.");
      }
    }
    window.addEventListener("message", onSWMessage);

    statusElement.textContent = "Reading magnet URI...";
    const magnetResponse = await fetch("magnet-link.txt");
    const magnetURI = (await magnetResponse.text()).trim();
    console.log("[App] Magnet URI:", magnetURI);

    statusElement.textContent = "Connecting to peers...";
    const torrent = client.add(magnetURI);

    // Grab references to elements that display stats
    const peersElement = document.getElementById("peers");
    const downloadSpeedElement = document.getElementById("downloadSpeed");
    const progressElement = document.getElementById("progress");
    const progressBar = document.getElementById("progressBar");
    const bufferedElement = document.getElementById("buffered");

    // Simple helper to convert speeds to human-readable format
    function prettyBytes(num) {
      const units = ["B/s", "kB/s", "MB/s", "GB/s"];
      let unitIndex = 0;
      while (num >= 1024 && unitIndex < units.length - 1) {
        num /= 1024;
        unitIndex++;
      }
      return num.toFixed(2) + " " + units[unitIndex];
    }

    function updateStats() {
      peersElement.textContent = torrent.numPeers;
      downloadSpeedElement.textContent = prettyBytes(torrent.downloadSpeed);
      progressElement.textContent = (torrent.progress * 100).toFixed(2) + "%";
      progressBar.style.width = (torrent.progress * 100).toFixed(2) + "%";
      // If you want to track buffering separately, you'd need custom logic
      bufferedElement.textContent = "N/A";
    }

    torrent.on("infoHash", () => console.log("[Torrent] infoHash:", torrent.infoHash));
    torrent.on("metadata", () => {
      console.log("[Torrent] metadata event. Name:", torrent.name);
      console.log("[Torrent] files:", torrent.files.map((f) => f.name));
    });
    torrent.on("ready", () => console.log("[Torrent] ready event."));
    torrent.on("done", () => console.log("[Torrent] done event. All data downloaded."));

    torrent.on("download", (bytes) => {
      console.log(
        `[Torrent] Downloaded chunk: ${bytes} bytes, total: ${torrent.downloaded}/${torrent.length}, progress: ${(torrent.progress * 100).toFixed(2)}%`
      );
      updateStats();
    });

    torrent.on("metadata", () => {
      statusElement.textContent = "Starting stream...";
      const file = torrent.files.find((f) =>
        f.name.endsWith(".mp4") || f.name.endsWith(".webm") || f.name.endsWith(".mkv")
      );
      if (!file) {
        statusElement.textContent = "No video file found in torrent!";
        return;
      }
      console.log("[Torrent] streaming file:", file.name);
      file.streamTo(videoPlayer);

      videoPlayer.play().catch(err => {
        console.warn("[App] Autoplay blocked or error:", err);
      });

      statusElement.textContent = "Streaming";
      updateStats();
    });
  } catch (err) {
    statusElement.textContent = `Error: ${err.message}`;
    console.error("[App]", err);
  }
})();
```

## src/package.json
```json
{
  "scripts": {
    "build": "webpack --config scripts/webpack.config.js"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@babel/preset-env": "^7.26.0",
    "babel-loader": "^9.2.1",
    "webpack": "^5.97.1",
    "webpack-cli": "^5.1.4"
  }
}

```

## scripts/webpack.config.js
```javascript
/*
<ai_context>
this is a new file
</ai_context>
*/

const path = require("path");

module.exports = {
  mode: "production",
  entry: "./index.js", // adapt this path to your main JS
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "../dist"),
  },
  devtool: "source-map", // avoids eval-based sourcemaps
  module: {
    rules: [
      {
        test: /\.js$/,
        use: {
          loader: "babel-loader",
        },
      },
    ],
  },
};

```

## dist/magnet-link.txt
```
magnet:?xt=urn:btih:08ada5a7a6183aae1e09d831df6748d566095a10&dn=Sintel&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969&tr=udp%3A%2F%2Ftracker.empire-js.us%3A1337&tr=wss%3A%2F%2Ftracker.btorrent.xyz&tr=wss%3A%2F%2Ftracker.openwebtorrent.com&tr=wss%3A%2F%2Ftracker.fastcast.nz&ws=https%3A%2F%2Fwebtorrent.io%2Ftorrents%2F
```

## dist/index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebTorrent Streaming Demo</title>
    <style>
      body {
        max-width: 960px;
        margin: 0 auto;
        padding: 20px;
        font-family: system-ui, -apple-system, sans-serif;
        background: #f5f5f5;
      }
      .player-container {
        background: #000;
        border-radius: 8px;
        overflow: hidden;
        margin: 20px 0;
      }
      video {
        width: 100%;
        max-height: 540px;
        display: block;
      }
      .stats {
        background: #fff;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        font-size: 14px;
        line-height: 1.5;
      }
      .progress-bar {
        background: #ddd;
        height: 4px;
        border-radius: 2px;
        margin: 10px 0;
        overflow: hidden;
      }
      .progress-bar-fill {
        background: #2196f3;
        height: 100%;
        width: 0%;
        transition: width 0.3s ease;
      }
      .stat-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        border-bottom: 1px solid #eee;
      }
      .stat-item:last-child {
        border-bottom: none;
      }
    </style>
  </head>
  <body>
    <h1>WebTorrent Streaming Demo</h1>
    <div class="player-container">
      <!-- NOTE: we add autoplay + muted here -->
      <video id="videoPlayer" controls autoplay muted></video>
    </div>
    <div class="progress-bar">
      <div id="progressBar" class="progress-bar-fill"></div>
    </div>
    <div class="stats">
      <div class="stat-item">
        <span>Status:</span>
        <span id="status">Initializing...</span>
      </div>
      <div class="stat-item">
        <span>Connected Peers:</span>
        <span id="peers">0</span>
      </div>
      <div class="stat-item">
        <span>Download Speed:</span>
        <span id="downloadSpeed">0 B/s</span>
      </div>
      <div class="stat-item">
        <span>Progress:</span>
        <span id="progress">0%</span>
      </div>
      <div class="stat-item">
        <span>Buffer:</span>
        <span id="buffered">0%</span>
      </div>
    </div>

    <script src="./bundle.js"></script>
  </body>
</html>
```

## dist/sw.min.js
```javascript
/*
<ai_context>
This service worker intercepts "webtorrent/..." requests and streams them.
We add logic to gracefully ignore canceled requests and avoid "close" errors.
</ai_context>
*/
(() => {
  "use strict";

  self.addEventListener("install", () => {
    console.log("[SW] Installed. skipWaiting() called.");
    self.skipWaiting();
  });

  self.addEventListener("activate", (evt) => {
    console.log("[SW] Activated. Claiming clients.");
    evt.waitUntil(self.clients.claim());
  });

  self.addEventListener("fetch", (event) => {
    const url = event.request.url;
    console.log("[SW] fetch event for:", url);

    // If keepalive path
    if (url.includes("/webtorrent/keepalive/")) {
      console.log("[SW] Keepalive request, returning HTTP 200");
      event.respondWith(new Response("", { status: 200 }));
      return;
    }

    // If cancel path
    if (url.includes("/webtorrent/cancel/")) {
      console.log("[SW] Cancel request, returning a canceled readable");
      event.respondWith(
        new Response(
          new ReadableStream({
            cancel() {
              // no-op
            }
          }),
          { status: 200 }
        )
      );
      return;
    }

    // If normal webtorrent streaming path
    if (url.includes("/webtorrent/")) {
      console.log("[SW] Intercepting WebTorrent request:", url);
      event.respondWith(handleWebTorrentRequest(event.request));
    }
    // else normal fetch
  });

  async function handleWebTorrentRequest(request) {
    const { url, method, headers } = request;
    console.log("[SW] handleWebTorrentRequest for:", url);

    // PostMessage to all open clients, let one respond
    const allClients = await self.clients.matchAll({
      type: "window",
      includeUncontrolled: true,
    });

    const result = await new Promise((resolve) => {
      let resolved = false;
      for (const client of allClients) {
        const mc = new MessageChannel();
        const { port1, port2 } = mc;
        port1.onmessage = (evt) => {
          if (!resolved) {
            resolved = true;
            resolve([evt.data, port1]);
          }
        };
        client.postMessage(
          {
            type: "webtorrent",
            url,
            method,
            headers: Object.fromEntries(headers.entries()),
          },
          [port2]
        );
      }
      setTimeout(() => {
        if (!resolved) {
          resolve([null, null]);
        }
      }, 3000);
    });

    const [responsePayload, messagePort] = result;
    if (!responsePayload) {
      console.warn("[SW] No client responded with a payload.");
      return new Response("No client responded", { status: 500 });
    }

    if (responsePayload.body !== "STREAM") {
      console.log("[SW] Returning non-stream response");
      return new Response(responsePayload.body || "Not a stream", {
        status: responsePayload.status || 200,
        headers: responsePayload.headers || { "Content-Type": "text/plain" },
      });
    }

    console.log("[SW] Opening streaming response...");
    let contentType = "video/mp4";
    if (url.endsWith(".webm")) contentType = "video/webm";

    // If the torrent is done or a partial request is canceled, we gracefully handle it
    return new Response(
      new ReadableStream({
        start(controller) {
          function requestNextChunk() {
            messagePort.postMessage(true);
          }
          function handleMessage({ data }) {
            if (!data) {
              console.log("[SW] No chunk data. Likely canceled or done, closing stream.");
              // If it's canceled or done, just close
              try {
                controller.close();
              } catch (_) {
                // ignore double close
              }
              return;
            }
            // data is a chunk of Uint8Array
            controller.enqueue(data);
            // ask for the next chunk
            requestNextChunk();
          }
          messagePort.onmessage = handleMessage;
          requestNextChunk();
        },
        cancel() {
          console.log("[SW] ReadableStream canceled by browser. Inform client to stop sending chunks.");
          messagePort.postMessage(false);
        },
      }),
      {
        status: 200,
        headers: { "Content-Type": contentType },
      }
    );
  }
})();
```


## XML Section

```xml
<code_changes>
  <changed_files>
    <file>
      <file_operation>CREATE</file_operation>
      <file_path>app/new_file.py</file_path>
      <file_code><![CDATA[
# New Python file
def new_function():
    pass
]]></file_code>
    </file>
    <!-- Add more file changes here -->
  </changed_files>
</code_changes>
```

**Other rules:**
- DO NOT remove `<ai_context>` sections. These are to provide you additional context about each file.
- If you create a file, add an `<ai_context>` comment section at the top of the file.
- If you update a file make sure its `<ai_context>` stays up-to-date.
- DO NOT add comments related to your edits.
- DO NOT remove my existing comments.

