/*
<ai_context>
This service worker intercepts "webtorrent/..." requests and streams them.
Added logs for debugging.
</ai_context>
*/
(() => {
  "use strict";

  let canceled = false;

  self.addEventListener("install", () => {
    console.log("[SW] Installed. skipWaiting() called.");
    self.skipWaiting();
  });

  self.addEventListener("activate", (evt) => {
    console.log("[SW] Activated. Claiming clients.");
    evt.waitUntil(self.clients.claim());
  });

  self.addEventListener("fetch", (event) => {
    // Log every fetch request to see if "webtorrent/..." ones appear here
    console.log("[SW] fetch event for:", event.request.url);

    const responsePromise = handleFetch(event);
    if (responsePromise) {
      event.respondWith(responsePromise);
    }
  });

  function handleFetch(event) {
    const { request } = event;
    const { url } = request;

    // Check if this is a webtorrent request that we should intercept
    if (url.includes("/webtorrent/")) {
      console.log("[SW] Intercepting WebTorrent request:", url);

      // If keepalive or cancel
      if (url.includes("/webtorrent/keepalive/")) {
        console.log("[SW] Return empty response for keepalive");
        return new Response();
      }
      if (url.includes("/webtorrent/cancel/")) {
        console.log("[SW] Return canceled readable for cancel request");
        return new Response(
          new ReadableStream({
            cancel() {
              canceled = true;
            },
          })
        );
      }

      return handleWebTorrentRequest(request);
    }

    // Otherwise we do not intercept
    return null;
  }

  async function handleWebTorrentRequest(request) {
    const { url, method, headers, destination } = request;
    console.log("[SW] handleWebTorrentRequest for:", url);

    // Find all client pages
    const allClients = await self.clients.matchAll({
      type: "window",
      includeUncontrolled: true,
    });

    // We'll message each client until one responds with data
    const results = await new Promise((resolve) => {
      for (const client of allClients) {
        const mc = new MessageChannel();
        const { port1, port2 } = mc;
        port1.onmessage = (evt) => {
          resolve([evt.data, port1]);
        };
        client.postMessage(
          {
            url,
            method,
            headers: Object.fromEntries(headers.entries()),
            destination,
            type: "webtorrent",
          },
          [port2]
        );
      }
    });

    const [responsePayload, messagePort] = results;
    if (!responsePayload) {
      console.warn("[SW] No response payload from any client.");
      return new Response("No client responded", { status: 500 });
    }
    if (responsePayload.body !== "STREAM") {
      // Return normal response
      console.log("[SW] Returning non-stream response");
      return new Response(responsePayload.body, responsePayload);
    }

    console.log("[SW] Opening streaming response...");
    // If the body is "STREAM", we handle it as a streaming scenario
    const stream = new ReadableStream({
      start(controller) {
        let keepAliveTimer;

        function sendAck() {
          messagePort.postMessage(true);
        }

        function handleMessage({ data }) {
          if (!data) {
            console.log(
              "[SW] Received 'close' signal from client. Closing stream."
            );
            clearTimeout(keepAliveTimer);
            controller.close();
            return;
          }
          // data is a chunk
          controller.enqueue(data);

          // Reset keepAlive
          if (destination !== "document") {
            clearTimeout(keepAliveTimer);
            keepAliveTimer = setTimeout(() => {
              console.warn("[SW] keepAliveTimer expired. Closing stream.");
              controller.close();
            }, 5000);
          }

          // ask the client for next chunk
          sendAck();
        }

        messagePort.onmessage = handleMessage;
        sendAck();
      },
      cancel() {
        console.log("[SW] ReadableStream canceled by browser.");
        messagePort.postMessage(false);
      },
    });

    return new Response(stream, responsePayload);
  }
})();
