(() => {
  "use strict";

  let e = !1;

  self.addEventListener("message", (event) => {
    console.log("SW: Message received:", event.data);
  });

  self.addEventListener("install", () => {
    console.log("SW: Install event");
    self.skipWaiting();
  });

  self.addEventListener("activate", () => {
    console.log("SW: Activate event");
    self.clients.claim();
  });

  self.addEventListener("fetch", (s) => {
    const t = ((s) => {
      const { url: t } = s.request;
      if (!t.includes(self.registration.scope + "webtorrent/")) {
        return null;
      }

      console.log("SW: Fetch event for webtorrent:", t);

      if (t.includes(self.registration.scope + "webtorrent/keepalive/")) {
        console.log("SW: Keepalive request");
        return new Response();
      }

      if (t.includes(self.registration.scope + "webtorrent/cancel/")) {
        console.log("SW: Cancel request");
        return new Response(
          new ReadableStream({
            cancel() {
              e = !0;
            },
          })
        );
      }

      return (async function (request) {
        console.log("SW: Stream request starting");

        const { url, method, headers, destination } = request.request;
        const clients = await self.clients.matchAll({
          type: "window",
          includeUncontrolled: true,
        });

        const [response, port] = await new Promise((resolve) => {
          for (const client of clients) {
            const channel = new MessageChannel();
            const { port1, port2 } = channel;

            port1.onmessage = ({ data }) => {
              console.log("SW: Got response from client");
              resolve([data, port1]);
            };

            client.postMessage(
              {
                url,
                method,
                headers: Object.fromEntries(headers.entries()),
                scope: self.registration.scope,
                destination,
                type: "webtorrent",
              },
              [port2]
            );
          }
        });

        const cleanup = () => {
          console.log("SW: Cleanup");
          port.postMessage(false);
          port.onmessage = null;
        };

        if (response.body !== "STREAM") {
          cleanup();
          return new Response(response.body, response);
        }

        return new Response(
          new ReadableStream({
            pull(controller) {
              return new Promise((resolve) => {
                port.onmessage = ({ data }) => {
                  if (data) {
                    controller.enqueue(data);
                  } else {
                    cleanup();
                    controller.close();
                  }
                  resolve();
                };
                port.postMessage(true);
              });
            },
            cancel() {
              cleanup();
            },
          }),
          response
        );
      })(s);
    })(s);

    if (t) {
      s.respondWith(t);
    }
  });
})();
